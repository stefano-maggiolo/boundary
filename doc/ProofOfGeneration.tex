% Copyright 2010 by Stefano Maggiolo and Nicola Pagani

\documentclass{amsart}

\usepackage[english]{babel}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{mathtools}

\newcommand{\arXiv}[1]{\href{http://arxiv.org/abs/#1}{arXiv:#1}}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
\theoremstyle{definition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{example}[theorem]{Example}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{notation}[theorem]{Notation}


\DeclareMathOperator{\bN}{\mathbb{N}}
\DeclareMathOperator{\mult}{mult}
\DeclareMathOperator{\MAX}{max}
%\DeclareMathOperator{\min}{min}

\newcommand{\graph}{\mathcal{G}}
\newcommand{\abs}[1]{\left|#1\right|}
\newcommand{\ubar}[1]{\underline{#1}}
\newcommand{\obar}[1]{\overline{#1}}
\newcommand{\psm}[1]{\left(\begin{smallmatrix}#1\end{smallmatrix}\right)}

\title{Generating stable modular graphs}
\author{Stefano Maggiolo}
\author{Nicola Pagani}
\date{\today}

\begin{document}

\begin{abstract}
  We present the program \texttt{strata}, whose source files are
  available at \href{http://people.sissa.it/~maggiolo/strata/}
  {\texttt{http://people.sissa.it/\~{}maggiolo/strata/}}. Given two
  natural numbers $g$ and $n$ satisfying $2g+n-2>0$, the program
  generates all genus $g$ stable graphs with $n$ marked points. Each such
  graph determines the topological type of a nodal stable curve of
  arithmetic genus $g$ with $n$ marked points. Our motivation comes
  from the fact that the boundary of the moduli space of stable genus
  $g$, $n$-pointed curves can be stratified by taking loci of curves
  of a fixed topological type.
\end{abstract}

\maketitle
\setcounter{tocdepth}{1}
\tableofcontents


\section{Introduction}
Moduli spaces of smooth algebraic curves have been defined and then
compactified in algebraic geometry by Deligne and Mumford in their
seminal paper~\cite{delignemumford}. The points in the boundary
correspond to nodal curves with finite automorphism group. These
curves are called \emph{stable curves}. The topology of one such curve
is encoded in a combinatorial object, called \emph{stable graph}. The
boundary of the moduli space admits a topological stratification,
whose elements are curves with fixed topology.

The combinatorics of the stable graphs have been investigated in
several papers in algebraic geometry, for many different purposes (see
for instance~\cite{modularoperads,opstall,opstall2,stephanie2}). Our
aim with this program is to provide an useful and effective tool to
generate all the stable graphs of genus $g$ with $n$ marked points up
to isomorphism, for low values of $g$ and $n$.

We construct an algorithm to generate all the stable, $n$-pointed
graphs of genus $g$, up to isomorphisms. The algorithm uses the
software nauty~(\cite{nauty}) to eliminate isomorphic graphs from the
list of graphs thus created. Since to check that two stable graphs are
isomorphic is computationally onerous, it uses several techniques to
generates a low number of stable graphs, provided that we want at
least one for every equivalence class. The algorithm generates
recursively the vectors of genera, marked points, and the adjacency
matrix. While it fills these data, it checks the stability condition
and the condition on the total genus as early as possible, in order to
minimize the time spent on the branches of the recursion that do not
lead to stable graphs. Our program works effectively with a bound on
the maximal number of vertices: $2g-2+n<13$. % TODO

Programs for enumerative computations on
$\overline{\mathcal{M}}_{g,n}$ have been implemented in both Maple and
Macaulay2~(\cite{faber,stephanie1,smith}). Our program can be used,
for example, to improve the results of~\cite[Section 5]{stephanie2},
or to prove simple results on the combinatorics of stable curves with
low genus (cfr.~\cite{busonero}, for example Corollary~5.3).



\section{What to generate}

From now on, we fix two natural numbers $G$ and $N$ such that $2
G-2+N>0$.  For every $K \in \bN^+$, we define $\ubar{K} = \{0, \dots,
K-1\}$. Let $\Sigma_K$ be the symmetric group on the set $\ubar{K}$.

\begin{definition}
  \mbox{}
  \begin{itemize}
  \item An \emph{undirected multigraph\/} $\graph$ is a couple $(V,
    E)$ with $V$ a finite set of \emph{vertices\/} and $E$ a finite
    multiset of \emph{edges\/} with elements in $V \times V/\Sigma_2$.
  \item The multiplicity of $(v, w)$ in $E$ is denoted by $\mult(v,
    w)$.
  \item The \emph{total multiplicity\/} of $\graph$, or its
    \emph{number of edges}, is $\abs{E}$: the cardinality of $E$ as a
    multiset.
  \item The \emph{degree\/} of a vertex $v$ is $\deg v \coloneqq 2
    \mult(v, v) + \sum_{w \neq v} \mult(v, w)$.
  \item A \emph{colored undirected multigraph\/} is a multigraph with
    some additional data attached to each vertex.
  \end{itemize}
\end{definition}

\begin{definition}\label{def:stable graph}
  A \emph{stable graph\/} of type $(G, N)$ is a colored undirected
  multigraph $\graph = (V, E)$, subject to the following conditions.
  \begin{enumerate}
  \item The color of a vertex $v$ is given by a pair of natural
    numbers $(g_v, n_v)$.
  \item \label{it:condition connected} $\graph$ is connected.
  \item \label{it:condition genus} Its \emph{total genus}, defined as
    $\sum_{v \in V} g_v + \abs{E} - (\abs{V} - 1)$, equals $G$.
  \item Its \emph{total number of marked points}, defined as $\sum_{v
      \in V} n_v$, equals $N$.
  \item \label{it:condition stability} Stability condition: $\deg v +
    n_v \geq 3$ for every vertex $v$ with $g_v = 0$.
  \end{enumerate}
\end{definition}

\begin{notation}
  We will call \emph{half edge} associated to a vertex $v$ either a
  marked point on $v$ or half of an edge that connects $v$ to an other
  vertex. In this way the stability condition can be rephrased in: for
  every vertex $v$ of genus $0$ there are at least $3$ half edges on
  it. An half edge is said to come from an edge if it is of the
  second type.
\end{notation}

Two stable graphs $\graph = (V, E, g, n)$ and $\graph^\prime =
(V^\prime, E^\prime, g^\prime, n^\prime)$ are \emph{isomorphic\/} if
there is a bijection $f\colon V \to V^\prime$ such that:
\begin{itemize}
\item $\mult(v, w) = \mult(f(v), f(w))$ for every $v, w \in V$;
\item $g_v = g^\prime_{f(v)}$ and $n_v = n^\prime_{f(v)}$ for every $v
  \in V$.
\end{itemize}
Our task is to generate one stable graph for each isomorphism class.

\begin{remark}
  Note that from the definition just given, we are working with an
  unordered set of marked points.
\end{remark}



\section{Description of our algorithm}

In this section we describe the general ideas of our algorithm. Let us
first introduce the notation we use in the program.

\begin{notation}\label{not:gnla}
  The set of vertices $V$ will always be $\ubar{K}$, so that vertices
  will be identified with natural numbers $i, j, \dots$. The
  multiplicity of the edge between $i$ and $j$ will be denoted by
  $a_{i,j}$: the symmetric matrix $a$ is called the \emph{adjacency
    matrix} of the stable graph. For convenience, we will denote $l_i
  = a_{i,i}$: it is the vector whose elements are the loops at the
  vertex $i$. For simplicity, we will consider $g_i$, $n_i$, $l_i$,
  $a_{i,j}$ to be defined also for $i$ or $j$ outside $\ubar{K}$, in
  which case their value is always assumed to be $0$.
\end{notation}

\begin{remark}
  In the following, we assume $\abs{V} > 1$ in order not to deal with
  degenerate cases. There are trivially $G+1$ stable graphs of type
  $(G, N)$ with one vertex. Indeed, if there is one vertex, the choice
  of the genus uniquely determines the number of loops on it after
  Definition~\ref{def:stable graph}.
\end{remark}

The program uses recursive functions to generate the data that
constitute a stable graph. In order, it generates the numbers $g_i$,
then the numbers $n_i$, $l_i$ (the diagonal part of the matrix $a$),
and finally, row by row, a symmetric matrix representing $a$.

Finally, when the data have all been generated, it tests that all the
conditions of Definition~\ref{def:stable graph} hold, in particular
that the graph is actually connected and satisfies the stability
conditions. Then it uses the software nauty \cite{nauty} to check if
this graph is isomorphic to a previously generated graph. If this is
not the case, it adds the graph to the list of graphs of genus $G$
with $N$ marked points.

%The program follows two principles: the first is to generate the
%smallest possible number of couples of isomorphic stable graphs, the
%second is to check the conditions of Definition~\ref{def:stable graph}
%as early as possible, to minimize the time spent in branches that do
%not lead to stable graphs.

 %The range is computed in such a way that assigning a value
%outside the range would not generate any stable graph; moreover, we
%tried to minimize the situations in which assigning a value inside the
%range would not generate any stable graph.
%We will describe in details the ranges in Section~\ref{sec:ranges}.

%Now let us focus on \underline{the first principle}.

A priori, for each entry of $g$, $n$, $l$, and $a$ the program tries
to fill that position with all integers. This of course is not
possible, indeed it is important to observe here that each datum is
bounded. From below, a trivial bound is $0$, that is, no datum can be
negative. Instead, a simple upper bound can be given for each entry of
$g$ by the number $G$, and for each entry of $n$ by the number
$N$. For $l$ and $a$, upper bounds are obtained from $G$ using the
condition on the total genus (Condition~\ref{def:stable graph}).

These bounds are coarse: Section \ref{sec:ranges} will be devoted to
prove sharper bounds, from above and from below. Also, we will make
these bounds dynamical: for instance assigning the value $g_0 > 0$
clearly lowers the bound for $g_i, i > 0$. Nonetheless, once we assess
these bounds, we are sure that the recursion terminates.

The algorithm follows the following principle: we want to generate the
smallest possible number of couples of isomorphic stable graphs. Here
we generalize the idea that to generate a vector for every class of
vectors of length $K$ modulo permutations, the simplest way is to
generate vectors whose entries are increasing. The program fills the
data in the order shown in the matrix
\begin{equation}\label{eq:big matrix}
  \begin{pmatrix}
    g_0 & g_1 & \cdots & g_{K-1}\\
    n_0 & n_1 & \cdots & n_{K-1}\\
    l_0 & l_1 & \cdots & l_{K-1}\\
    \hline
    \bullet & a_{0,1} & \cdots & a_{0,K-1}\\
    a_{1,0} & \bullet & \ddots & \vdots\\
    \vdots & \ddots & \bullet & a_{K-2,K-1}\\
    a_{K-1,0} & \cdots & a_{K-1,K-2} & \bullet
  \end{pmatrix}\text{,}
\end{equation}
and generates only matrices whose columns are ordered. Loosely
speaking, we intend that we are ordering the column lexicographically,
but this requires a bit of care, for two reasons:
\begin{itemize}
\item the matrix $a$ needs to be symmetric; in the program we generate
  only the strictly upper triangular part;
\item the diagonal of $a$ need not be considered when deciding if a
  column is greater or equal than the previous one.
\end{itemize}

Therefore, to be precise, we define a relation (\emph{order}) for
adjacent columns. Let us call $c_{j-1}$ and $c_j$ two adjacent columns
of the matrix~\ref{eq:big matrix}. They are said to be equivalent if
$c_{j-1,i} = c_{j,i}$ for any $i \notin \{j-1+3, j+3\}$. If they are
not equivalent, denote with $i_0$ the minimum index such that $i_0
\notin \{ j-1+3, j+3\}$ and $c_{j-1,i_0} \neq c_{j,i_0}$. Then we
state the relation $c_{j-1} < c_j$ if and only if $c_{j-1,i_0} <
c_{j,i_0}$. We do not define the relation for non-adjacent columns.
We say that the data are ordered when the columns are weakly
increasing, that is if, for all $j$, either $c_{j-1}$ is equivalent to
$c_j$ or $c_{j-1} < c_j$.

To ensure that the columns are ordered (in the sense we explained
before), the program keeps track of \emph{divisions}. We start filling
the genus vector $g$ in a non decreasing way, and every time a value
$g_i$ strictly greater than $g_{i-1}$ is assigned, we put a division
before $i$.
% TODO: the following needs to be rewritten
This means that, in the following, when we decide the
value of a datum regarding index $i$, we can ignore the value of that
datum for the index $i-1$, because the column $c_i$ is already bigger
than the column $c_{i-1}$.
%Otherwise, if there is not a division before $i$, we would
%have been forced to put a value which is bigger or equal than the one
%in position $i-1$.

After completing $g$, we start filling the vector $n$ in such a way
that, within two divisions, it is non decreasing. Again we introduce a
division before $i$ every time we assign a value $n_i$ strictly
greater than $n_{i-1}$. We follow this procedure also for the vector
$l$.

Finally, we start filling the rows of the matrix $a$. Here the
procedure is a bit different, because, even if we fill only the upper
triangular part, the conditions that the columns must be sorted
involves also the lower triangular part. A small computation gives
that the value of $a_{i,j}$ is assigned starting from:
\[
\begin{cases}
  0 & \text{if there are divisions before $i$ and $j$}\\
  a_{i,j-1} & \text{if there is a division before $i$ but not before
    $j$}\\
  a_{i-1,j} & \text{if there is a division before $j$ but not before
    $i$}\\
  \max\{a_{i,j-1}, a_{i-1,j}\} & \text{if there are no divisions
    before $i$ or $j$,}
\end{cases}
\]
and we put a division before $i$ if $a_{i,j} > a_{i-1,j}$ and a division
before $j$ if $a_{i,j} > a_{i,j-1}$.

We cannot conclude immediately that this procedure gives us all
possible data up to permutations as in the case of a single
vector. This is because the transformation that the matrix undergo
when a permutation is applied is more complicated: for the first three
rows, it just permutes the columns, but for the remaining rows, it
permutes both rows and columns. Indeed, to prove that the procedure of
generating only ordered columns does not miss any stable graph is the
content of the following section.



\section{The program generates all graphs}\label{sec:proof}

We want to prove the following result.

\begin{proposition}\label{prop:main}
  The algorithm described in the previous section generates at least
  one graph for every isomorphism class of graphs.
\end{proposition}

From now on, we fix the number of vertices $K$, and focus on proving
that the algorithm generates at least one graph for every isomorphism
class of graphs with $K$ vertices.

We can assume that the graphs generated by the algorithm are connected
and stable, since we explicitly check these conditions for each graph.

%Moreover, in the previous section we proved that all the constraints
%we put on $g$, $n$, $l$, $a$ (apart from the one coming from
%divisions) are justified by the fact if we assign a value outside
%those constraints, the graph we obtain has no hope of becoming stable
%once completed. As a consequence, for simplicity we can prove
%Proposition~\ref{prop:main} assuming that the algorithm uses only the
%divisions constraints.

\begin{notation}
  We have seen previously that we can encode the data of a stable
  graph in a quadruple $G \coloneqq (g, n, l, a)$. We denote by
  $\mathcal{A}$ the set of all quadruples that define a stable graph,
  whereas by $\mathcal{M}$ the set of all quadruples generated by the
  algorithm described in the previous section.
\end{notation}

Since our program only generates stable graphs, we have the inclusion
$\mathcal{M} \subset \mathcal{A}$; hence, in order to prove
Proposition~\ref{prop:main}, it is equivalent to prove that every $G
\in \mathcal{A}$ is in $\mathcal{M}$ up to applying a permutation of
$\ubar{K}$. The key point is to give two characterizations
(Lemma~\ref{lemma:char1} and~\ref{lemma:char2}) of the property of
being an element of $\mathcal{M}$.

\begin{lemma}\label{lemma:char1}
  Let $G = (g, n, l, a) \in \mathcal{A}$; then $G \in \mathcal{M}$ if
  and only if:
  \begin{multline*}
    \forall (i,j)\colon
    j \not\in \{i-1, i\},\\
    \begin{aligned}
      g_{i-1} &> g_i &&\text{does not happen,}\\
      n_{i-1} &> n_i &\Rightarrow\  & g_{i-1} < g_i\,\text{,}\\
      l_{i-1} &> l_i &\Rightarrow\  & g_{i-1} < g_i \vee n_{i-1} < n_i\,\text{, and}\\
      a_{i-1,j} &> a_{i,j} &\Rightarrow\ & g_{i-1} < g_i \vee n_{i-1}
      < n_i \vee l_{i-1} < l_i \vee\\
      &&&\ \exists j^\prime < j: j^\prime \not\in \{i-1,i\} \wedge
      a_{i-1,j^\prime} < a_{i,j^\prime}\,\text{.}
    \end{aligned}
  \end{multline*}
\end{lemma}

\begin{proof}
  %We have seen before Notation~\ref{not:gnla} that the program tries
  %for each piece of data in $g$, $n$, $l$, or $a$ a range of
  %values. The higher endpoint of this range is computed in order that
  %a bigger value would make the graph unstable. The lower endpoint is
  %used in two ways: to avoid non-stable graphs (as for the higher
  %endpoint), and to decrease the number of stable graph that are going
  %to be isomorphic to an already generated graph.

  %This second aim is the only one that we are interested in here
  %(since non-stable graphs are also not in $\mathcal{A}$). We
  %accounted for it with the requirement that the value of every
  %position is bigger or equal to the value of the one on the left (and
  %the one on the top, in the case of $a$), if there are no divisions
  %for that index.

  The four conditions in the statements are a translation of our algorithm. The only non immediate one is the last: the condition on the matrix $a$. Let us study it in more details.
  \begin{enumerate}
  \item If $a_{i-1, j} > a_{i, j}$, then there should be a division
    before $i$, that is, there should be a couple in the red area (the
    yellow area corresponds to $(i,j)$ and $(i-1,j)$) for which the
    darker is strictly greater than the corresponding lighter; on the
    right we can see how to simplify this condition using the symmetry
    of the matrix:
    \[
    \begin{tikzpicture}[xscale=0.2,yscale=-0.2,baseline=-40]
      \fill [yellow] (12,6) -- (12,8) -- (11,8) -- (11,6) -- cycle;
      \fill [red!50] (8,6) -- (8,7) -- (11,7) -- (11,6) -- cycle;
      \fill [red!100] (8,7) -- (8,8) -- (11,8) -- (11,7) -- cycle;
      \fill [red!50] (6,0) -- (6,6) -- (7,6) -- (7,0) -- cycle;
      \fill [red!100] (7,0) -- (7,6) -- (8,6) -- (8,0) -- cycle;

      \draw (0,0) -- (15,0) -- (15,15) -- (0,15) -- cycle;
      \foreach \x in {1,2,...,14}
      {
        \draw [very thin] (\x,\x) -- (15,\x);
        \draw [very thin] (\x,0) -- (\x,\x);
      }
      \foreach \x in {0,1,...,14}
        \filldraw (\x,\x) -- (\x,\x+1) -- (\x+1,\x+1) -- (\x+1,\x) -- cycle;
    \end{tikzpicture}
    \qquad \leadsto \qquad
    \begin{tikzpicture}[xscale=0.2,yscale=-0.2,baseline=-40]
      \fill [yellow] (12,6) -- (12,8) -- (11,8) -- (11,6) -- cycle;
      \fill [red!50] (8,6) -- (8,7) -- (11,7) -- (11,6) -- cycle;
      \fill [red!100] (8,7) -- (8,8) -- (11,8) -- (11,7) -- cycle;
      \fill [red!50] (0,6) -- (6,6) -- (6,7) -- (0,7) -- cycle;
      \fill [red!100] (0,7) -- (6,7) -- (6,8) -- (0,8) -- cycle;

      \draw (0,0) -- (15,0) -- (15,15) -- (0,15) -- cycle;
      \foreach \x in {1,2,...,14}
      {
        \draw [very thin] (0,\x) -- (15,\x);
        \draw [very thin] (\x,0) -- (\x,15);
      }
      \foreach \x in {0,1,...,14}
        \filldraw  (\x,\x) -- (\x,\x+1) -- (\x+1,\x+1) -- (\x+1,\x) -- cycle;
    \end{tikzpicture}
    \]
  \item If $a_{i, j-1} > a_{i, j}$, then there should be a division
    before $j$, i.e.\ there should be a couple in the red area for
    which the darker is strictly greater than the lighter; on the
    right, the simplification shows that the condition takes the same
    form of the previous one:
    \[
    \begin{tikzpicture}[xscale=0.2,yscale=-0.2,baseline=-40]
      \fill [yellow] (13,7) -- (13,8) -- (11,8) -- (11,7) -- cycle;
      \fill [red!50] (11,0) -- (11,7) -- (12,7) -- (12,0) -- cycle;
      \fill [red!100] (12,0) -- (12,7) -- (13,7) -- (13,0) -- cycle;

      \draw (0,0) -- (15,0) -- (15,15) -- (0,15) -- cycle;
      \foreach \x in {1,2,...,14}
      {
        \draw [very thin] (\x,\x) -- (15,\x);
        \draw [very thin] (\x,0) -- (\x,\x);
      }
      \foreach \x in {0,1,...,14}
        \filldraw (\x,\x) -- (\x,\x+1) -- (\x+1,\x+1) -- (\x+1,\x) -- cycle;
    \end{tikzpicture}
    \qquad \leadsto \qquad
    \begin{tikzpicture}[xscale=0.2,yscale=-0.2,baseline=-40]
      \fill [yellow] (7,13) -- (8,13) -- (8,11) -- (7,11) -- cycle;
      \fill [red!50] (0,11) -- (7,11) -- (7,12) -- (0,12) -- cycle;
      \fill [red!100] (0,12) -- (7,12) -- (7,13) -- (0,13) -- cycle;

      \draw (0,0) -- (15,0) -- (15,15) -- (0,15) -- cycle;
      \foreach \x in {1,2,...,14}
      {
        \draw [very thin] (0,\x) -- (15,\x);
        \draw [very thin] (\x,0) -- (\x,15);
      }
      \foreach \x in {0,1,...,14}
        \filldraw (\x,\x) -- (\x,\x+1) -- (\x+1,\x+1) -- (\x+1,\x) -- cycle;
    \end{tikzpicture}
    \]
  \end{enumerate}

  Summarizing, using the fact that the matrix $a$ is symmetric, we can
  provide the desired characterization of the stable graphs generated
  by the algorithm.
\end{proof}

\begin{definition}
  Let $G = (g, n, l, a) \in \mathcal{A}$. A piece of data $g_i$,
  $n_i$, $l_i$, or $a_{i,j}$ is called a \emph{breaking position\/} if
  it does not satisfy the four conditions of
  Lemma~\ref{lemma:char1}.
\end{definition}

In particular, in view of the last definition, Lemma~\ref{lemma:char1} translates into the following statement: \emph{A stable graph $G \in \mathcal{A}$ has a breaking position
  if and only if $G$ is not an element of $\mathcal{M}$}.

We now introduce a total order on the set $\mathcal{A}$ of graphs $G =
(g,n,l,a)$. If $G$ is such a graph, let $v(G)$ be the vector obtained
by juxtaposition of the vectors $g$, $n$, $l$ and of the rows of the
upper triangular part of $a$. For example, if
\[
  G = \begin{pmatrix}
    0 & 0 & 2 & 0\\
    1 & 1 & 0 & 1\\
    0 & 0 & 0 & 0\\
    \hline
    \bullet & 1 & 1 & 1\\
    1 & \bullet & 2 & 1\\
    1 & 2 & \bullet & 0\\
    1 & 1 & 0 & \bullet
  \end{pmatrix}
\]
(with the same meaning of~\ref{eq:big matrix}), then
\[
v(G) = (0, 0, 2, 0,\quad 1, 1, 0, 1,\quad 0, 0, 0, 0,\quad 1, 1,
1,\quad 2, 1,\quad 0)\,\text{.}
\]

\begin{definition} \label{def:order} If $G, H \in \mathcal{A}$, we
  write $G \prec H$ if and only if $v(G)$ is smaller than $v(H)$ in
  the lexicographic order.
\end{definition}

\begin{notation}
  If $\sigma \in \Sigma_K$ is a permutation and $G = (g, n, l, a)$ is
  a graph, then we can apply $\sigma$ to the entries of the data of
  $G$, obtaining an isomorphic graph. We denote this new graph by
  $\sigma G$. We denote by $\sigma_{i,j}$ the element of $\Sigma_K$ that corresponds to the transposition of $i, j \in \ubar{K}$.
\end{notation}

\begin{lemma}\label{lemma:char2}
  Let $G \in \mathcal{A}$; then $G \in \mathcal{M}$ if and only if $G$
  is minimal in the set
  \[
  \bigl\{ \sigma_{i-1,i} G \,\mid\, 1<i<K \bigr\}\text{.}
  \]
  with respect to the order given in Definition~\ref{def:order}.
\end{lemma}

\begin{proof}
  We use Lemma~\ref{lemma:char1}; in particular we prove that $G$ is
  not minimal if and only if there is a breaking position.

  Assume there are breaking positions in $G$; if the first is in $g$,
  $n$, or $l$, it is trivial to see that transposing it with the
  previous one gives a smaller graph. If breaking positions are only
  in $a$ (i.e., if $g$, $n$, and $l$ are constant), assume that
  $a_{i,j}$ is the smallest with respect to the lexicographic order on
  $(i,j)$. We deduce that for all $j^\prime < j$ not in $\{i-1,i\}$,
  we have $a_{i-1, j^\prime} = a_{i, j^\prime}$. %A priori the equality
 % sign should be a ``less or equal to'', but if the first was strictly
 % smaller than the second, then $(i,j^\prime)$ would have been a
 % smaller breaking position.
  Let $H \coloneqq \sigma_{i-1,i} G$; the
  following pictures sum up the differences between $G$ and $H$: the
  left one represents the case $i < j$, the right one the case $i >
  j$:
  \[
  \begin{tikzpicture}[xscale=0.2,yscale=-0.2,baseline=-40]
    \fill [gray!50] (0,0) -- (15,0) -- (15,15) -- (0,15) -- cycle;
    \fill [yellow] (12,6) -- (12,8) -- (11,8) -- (11,6) -- cycle;
    \fill [yellow] (6,12) -- (8,12) -- (8,11) -- (6,11) -- cycle;
    \fill [red!50] (12,6) -- (12,8) -- (15,8) -- (15,6) -- cycle;
    \fill [red!50] (6,12) -- (8,12) -- (8,15) -- (6,15) -- cycle;
    \fill [gray] (0,6) -- (0,8) -- (11,8) -- (11,6) -- cycle;
    \fill [gray] (6,0) -- (8,0) -- (8,11) -- (6,11) -- cycle;
    \fill [gray!50] (6,6) -- (6,8) -- (8,8) -- (8,6) -- cycle;

    \draw (0,0) -- (15,0) -- (15,15) -- (0,15) -- cycle;
    \foreach \x in {1,2,...,14}
    {
      \draw [very thin] (0,\x) -- (15,\x);
      \draw [very thin] (\x,0) -- (\x,15);
    }
    \foreach \x in {0,1,...,14}
      \filldraw (\x,\x) -- (\x,\x+1) -- (\x+1,\x+1) -- (\x+1,\x) -- cycle;
  \end{tikzpicture}
  \qquad\qquad
  \begin{tikzpicture}[xscale=0.2,yscale=-0.2,baseline=-40]
    \fill [gray!50] (0,0) -- (15,0) -- (15,15) -- (0,15) -- cycle;
    \fill [yellow] (7,13) -- (8,13) -- (8,11) -- (7,11) -- cycle;
    \fill [yellow] (13,7) -- (13,8) -- (11,8) -- (11,7) -- cycle;
    \fill [red!50] (8,11) -- (8,13) -- (15,13) -- (15,11) -- cycle;
    \fill [red!50] (11,8) -- (13,8) -- (13,15) -- (11,15) -- cycle;
    \fill [gray] (0,11) -- (0,13) -- (7,13) -- (7,11) -- cycle;
    \fill [gray] (11,0) -- (13,0) -- (13,7) -- (11,7) -- cycle;
    \fill [gray!50] (11,11) -- (11,13) -- (13,13) -- (13,11) -- cycle;

    \draw (0,0) -- (15,0) -- (15,15) -- (0,15) -- cycle;
    \foreach \x in {1,2,...,14}
    {
      \draw [very thin] (0,\x) -- (15,\x);
      \draw [very thin] (\x,0) -- (\x,15);
    }
    \foreach \x in {0,1,...,14}
      \filldraw (\x,\x) -- (\x,\x+1) -- (\x+1,\x+1) -- (\x+1,\x) -- cycle;
  \end{tikzpicture}
  \]
  In particular:
  \begin{itemize}
  \item the yellow area is the smallest breaking position and the
    position preceding it (on its left or on the top), and the two are
    swapped in $H$;
  \item the light grey area is of course unchanged;
  \item the dark grey area is swapped, but this is unnoticeable as
    $a_{i-1,j^\prime} = a_{i,j^\prime}$;
  \item the light red area is swapped and may change the matrix.
  \end{itemize}
  So, since $a_{i-1,j} > a_{i, j}$, then $H \prec G$ and therefore $G$
  is not minimal (note that it is essential to consider only the upper
  triangular part of $a$ to define $\prec$).

  Conversely, let $i$ be such that $H \coloneqq \sigma_{i-1,i} G \prec
  G$. If the first difference between $G$ and $H$ lies in $g$, $n$, or
  $l$, then it is easy to see that the corresponding position is
  breaking. Otherwise, if the vectors $g,n,l$ are equal in $G$ and in $H$, we can see the difference between $G$ and $H$
  in the previous pictures on the matrices. Since $H \prec G$, then, going from the
  top to the diagonal and then to the right, we see that the first
  swapping that changes the matrix (that is, one that swaps different
  numbers), represented in yellow, exchanges a small number at a big
  position (with respect to the lexicographic order) with a big number
  at a small position. Hence this gives a breaking position for $G$.
\end{proof}

\begin{remark}
  Given a graph $G$, the number of graphs isomorphic to $G$ that our
  program generates is then trivially bounded by $\abs{\Sigma_K}/(K-1)
  = K\cdot (K-2)!$.
  % TODO: Give empirical estimate on the real bound (if it is linear,
  % exponential, ...)
\end{remark}

The proof of Proposition~\ref{prop:main} can now be easily deduced
arguing as in the following example.

\begin{example}
  Let $G_0 = G \in \mathcal{A}$ be the graph of the previous
  example:
  \[
  G_0 = \psm{ 0 & 0 & 2 & 0\\ 1 & 1 & 0 & 1\\ 0 & 0 & 0 & 0\\ & 1 & 1
    & 1\\ && 2 & 1\\ &&& 0 }\text{.}
  \]
  This graph is stable but not in $\mathcal{M}$ because, for example,
  $g_2 > g_3$ implies that $g_3$ is a breaking position. This is
  the smallest breaking position, thus we apply the permutation $\sigma_{2,3}$, obtaining
  the graph
  \[
  G_1 \coloneqq \sigma_{2,3} G_0 = \psm{ 0 & 0 & 0 & 2\\
    1 & 1 & 1 & 0\\ 0 & 0 & 0 & 0\\ & 1 & 1 & 1\\ && 1 & 2\\ &&& 0 }
  \prec G_0\text{.}
  \]
  Now $a_{2,3}$ is the smallest breaking position; applying
  $\sigma_{1,2}$, we obtain
  \[
  G_2 \coloneqq \sigma_{1,2} G_1 = \psm{ 0 & 0 & 0 & 2\\ 1 & 1 & 1 &
    0\\ 0 & 0 & 0 & 0\\ & 1 & 1 & 1\\ && 1 & 0\\ &&& 2 } \prec
  G_1\text{.}
  \]
  The new smallest breaking position is $a_{1,3}$, so applying the
  transposition $\sigma_{0,1}$ we have
  \[
  G_3 \coloneqq \sigma_{0,1} G_2 = \psm{ 0 & 0 & 0 & 2\\ 1 & 1 & 1 &
    0\\ 0 & 0 & 0 & 0\\ & 1 & 1 & 0\\ && 1 & 1\\ &&& 2 } \prec
  G_2\text{.}
  \]
  The graph $G_3$ is finally in $\mathcal{M}$ and we can verify that no
  transposition can decrease it.
\end{example}

\begin{proof}[Proof of Proposition~\ref{prop:main}]
  Recall that we have to prove that for every $G \in \mathcal{A}$,
  there is a permutation $\sigma \in \Sigma_K$ such that $\sigma G \in
  \mathcal{M}$.

  So, let $G_0 = G \in \mathcal{A}$. If $G \in \mathcal{M}$, then we
  are done; otherwise, $G$ does not satisfy the condition of
  Lemma~\ref{lemma:char2}, hence there is a transposition
  $\sigma_{i-1, i}$ such that $G_1 = \sigma_{i-1,i} G_0 \prec G_0$.

  The iteration of this process comes to an end (that is, we arrive to
  a matrix in $\mathcal{M}$) since the set
  \[
  \bigl\{ \sigma G \mid \sigma \in \Sigma_K\bigr\}
  \]
  is finite.
\end{proof}



\section{Description of the ranges}\label{sec:ranges}

In the previous section we have introduced the algorithm, by
describing the divisions. In this section we introduce accurate ranges
for the possible values of $g,n,l$ and $a$. In particular we try to
obtain estimates on the upper extremum for each datum to be filled.

We will deduce from the
conditions of Definition~\ref{def:stable graph} some other necessary
conditions that can be checked before the graph is defined in its
entirety. More precisely, every single datum is assigned trying all
the possibilities within a range that depends upon the values of $G$
and $N$, and upon the values of the data that have already been
filled.


\begin{notation}
  At any time during the algorithm, we let $e^{\MAX}$ be the maximum
  number of edges that could be placed after that time, and $c$ be the
  number of couples of (different) vertices already connected by an
  edge. We let $p_1$ be the number of vertices $i$ to which the
  algorithm has assigned $g_i = 0$. Note that the final value of $p_1$
  is determined when the first genus greater than $0$ is assigned, in
  particular the final value of $p_1$ is determined at the end of the
  assignment of the values to the vector $g$.
\end{notation}

\begin{notation}
  When deciding $g$, $n$, or $l$, we let $n^{(2)}_i$ be the minimum
  between $2$ and the number of half edges already assigned to the
  $i$-th vertex. This is justified by the fact that we know that at
  least one half edge will be assigned to the $i$-th vertex to connect
  it to the rest of the graph. Hence, whenever $g_i = 0$, $n^{(2)}_i$
  is the number of \emph{stabilizing\/} half edges at the vertex $i$:
  one half edge is needed to connect the vertex to the rest of the graph,
  and then at least two more half edges are needed to stabilize the
  vertex. When deciding $a_{i,j}$, it is also useful to have defined
  $h_i$, the total number of half edges that hit the $i$-th
  vertex. Finally, we define
  \begin{align*}
    G_i &\coloneqq \sum_{i^\prime < i} g_{i^\prime}\,\text{,} &
    N_i &\coloneqq \sum_{\substack{i^\prime < i\\g_{i^\prime} = 0}} n_{i^\prime}\,\text{,}\\
    N^{(2)} &\coloneqq \sum_{g_{i^\prime} = 0} n^{(2)}_{i^\prime}\,\text{,} &
    N^{(2)}_i &\coloneqq \sum_{\substack{i^\prime < i\\g_{i^\prime} = 0}} n^{(2)}_{i^\prime}\,\text{;}\\
    L_i &\coloneqq \sum_{i^\prime < i} l_{i^\prime}\,\text{,} &
    A_{i,j} &\coloneqq \sum_{\mathclap{i^\prime < i \vee j^\prime < j}} a_{i^\prime, j^\prime}\,\text{.}
  \end{align*}
\end{notation}

We are now ready to describe the ranges in which the data can vary.
We study subsequently the cases of $g$, $n$, $l$ and $a$, thus
following the order of the recursions of our algorithm. Each range is
described by presenting a first list of general constraints on the
parameters and then by presenting a second list containing the
extimates that allow the definitions of the actual ranges.


\subsection{Range for $g_i$}

When the algorithm is deciding the value of $g_i$, we have the
following situation:
\begin{itemize}
\item $e^{\MAX} = G - G_i + K - 1$ by Condition~\ref{it:condition genus};
\item amongst the $e^{\MAX}$ edges, there are necessarily $K-1$
  non-loop edges (to connect the graph); these $K-1$ edges give one
  half edge for each vertex, whereas we can choose arbitrarily where
  to send the other $K-2$ half edges; conversely, the $2(e^{\MAX} - K
  +1)$ half edges of the remaining edges can be associated to any
  vertex; therefore, the maximum number of half edges coming from
  edges (not counting those that are needed to connect the graph) is
  $2e^{\MAX} - K = 2(G - G_i) + K - 2$;
\item the maximum number of half edges coming from marked points is
  $N$;
\item we need $2p_1$ half edges to stabilize the genus $0$ vertices,
  since one half edge comes for free from the connection of the graph.
\end{itemize}

We use the following conditions to limit the choices we have for
$g_i$:
\begin{enumerate}
\item since $g$ is the first vector to be generated, there is no
  division before $i$, hence
  \[
  g_i \geq g_{i-1}\text{;}
  \]
  remember that $g_j = 0$ whenever $j \not\in \ubar{K}$;
\item we need at least $K-1$ non-loop edges, hence (using the fact
  that $\sum_{j \geq i} g_j \geq (K-i) g_i$)
  \begin{align*}
    &e^{\MAX} \geq K-1\\
    &\qquad\Rightarrow G - G_i - (K-i) g_i + K-1 \geq K-1\\
    &\qquad\Rightarrow (K-i)g_i \leq G - G_i\,\text{;}
  \end{align*}
\item in order to stabilize the $p_1$ vertices of genus $0$ (using the
  fact that one stabilizing half edge comes for free by connection) we
  must have
  \begin{align*}
    &2 p_1 \leq 2e^{\MAX} - K + N\\
    &\qquad\Rightarrow 2p_1 \leq G - G_i - (K-i)g_i - K + N\\
    &\qquad\Rightarrow (K-i)g_i \leq G - G_i - K + N - 2p_1\,\text{.}
  \end{align*}
\end{enumerate}



\subsection{Range for $n_i$}

When deciding $n_i$, we have the following situation:
\begin{itemize}
\item as before, $e^{\MAX} = G - G_K + K - 1 \geq K-1$, and the
  maximum number of half edges still to be assigned and coming from
  edges is $2e^{\MAX} - K = 2(G - G_K) + K - 2$;
\item the number of half edges still to be assigned and coming from
  marked points is $N - N_i - n_i$;
\item we need $2p_1 - N^{(2)}_i - n^{(2)}_i$ half edges to
  stabilize the first $p_1$ vertices;
\item if $g_i = 0$, we need $2(i+1) - N^{(2)}_i - n^{(2)}_i$ half
  edges to stabilize the first $i+1$ vertices, and we cannot use
  marked points.
\end{itemize}

The following conditions define then the ranges for the possible
choices for $n_i$:

\begin{enumerate}
\item if there is not a division before $i$ (that is, if $g_i =
  g_{i-1}$), then we require $n_i \geq n_{i-1}$; otherwise, just $n_i
  \geq 0$;
\item we cannot assign more than $N$ marked points, hence (where we
  treat the case of $g_i = 0$ in a special way)
  \begin{align*}
    &N_i + n_i \leq N\\
    &\qquad\Rightarrow n_i \leq N - N_i\\
    &\qquad\Rightarrow (p_1 - i)n_i \leq N - N_i\text{ if moreover $g_i = 0$.}
  \end{align*}
\item if $g_i = 0$, for the purpose of stabilizing the first $i+1$
  curves we cannot use marked points anymore, therefore we have
  \begin{align*}
    &2 (i+1) - N^{(2)}_i - n^{(2)}_i \leq (2(G - G_K) + K - 2)\\
    &\qquad\Rightarrow n^{(2)}_i = \min(2, n_i) \geq - (2(G - G_K) + K - 2) + (2(i+1) - N^{(2)}_i)\\
    &\qquad\Rightarrow
    \begin{cases}
      \text{impossible} & \text{if $\mathrm{RHS} > 2$}\\
      n_i \geq \mathrm{RHS} & \text{otherwise.}
    \end{cases}
  \end{align*}
\end{enumerate}

\subsection{Range for $l_i$}

After deciding $l_i$, this is the situation:
\begin{itemize}
\item $e^{\MAX} = G - G_K - L_i - l_i + K - 1 \geq K-1$, and the
  maximum number of half edges coming from edges to assign is
  $2e^{\MAX} - K = 2(G - G_K - L_i - l_i) + K - 2$;
\end{itemize}

The conditions on $l_i$ are then the following:
\begin{enumerate}
\item if there is not a division before $i$, then we require $l_i \geq
  l_{i-1}$; otherwise, just $l_i \geq 0$;
\item we need at least $K-1$ non-loop edges, hence
  \begin{align*}
    &e^{\MAX} \geq K-1\\
    &\qquad\Rightarrow G - G_K - L_i - l_i + K-1 \geq K-1\\
    &\qquad\Rightarrow l_i \leq G - G_K - L_i\,\text{;}
  \end{align*}
\item let $z$ be the index of the genus $0$ vertex with the least
  number of stabilizing half edges such that $z < i$; it already has
  $n_z + 2l_z$ half edges, but we cannot use loops anymore to
  stabilize it; hence,
  \begin{align*}
    &\max(0, 2-n_z-2l_z) \leq G - G_K - L_i - l_i + K - 1\\
    &\qquad\Rightarrow l_i \leq G - G_k - L_i + K - 3 + n_z + 2l_z
  \end{align*}
\item assume $g_i = 0$; if $l_i > 0$, we are adding to the $i$-th
  vertex $2-n^{(2)}_i$ stabilizing half edges, and to stabilize the
  $p_1$ genus $0$ vertices, we need to have
  \begin{align*}
    &2 p_1 - N^{(2)} - (2-n^{(2)}_i) \leq 2e^{\MAX} - K\\
    &\qquad\Rightarrow 2p_1 - N^{(2)} - (2-n^{(2)}_i) \max(0, 2-m_i) \leq 2(G - G_K - L_i - l_i + K - 1) - K\\
    &\qquad\Rightarrow 2l_i \leq 2(G - G_K - L_i) + K + N^{(2)} - n^{(2)}_i - 2p_i\,\text{.}
  \end{align*}
\item assume $g_i = 0$; after deciding $l_i$, we still have $e^{\MAX}$
  edges to place, and each of them can contribute with one half edge
  to the stabilization of the $i$-th vertex; moreover, one of that
  half edges is already counted toward the stabilization; hence
  \begin{align*}
    &n_i + 2l_i + (e^{\MAX} - 1) \geq 2\\
    &\qquad\Rightarrow n_i + 2l_i + G - G_K - L_i - l_i + K - 1 - 1 \geq 2\\
    &\qquad\Rightarrow l_i \geq 4 - n_i - G + G_K + L_i - K\,\text{.}
  \end{align*}
\end{enumerate}

\subsection{Range for $a_{i,j}$}

After deciding $a_{i,j}$, this is the situation:
\begin{itemize}
\item in this section, the word ``stabilized'' goes back to its
  original meaning, i.e., it means ``with at least $3$ half edges'';
  this is necessary since here we may have already placed some
  non-loop edges, hence we cannot track easily which vertices already
  are connected to the rest of the graph and which are not;
\item $e^{\MAX} = G - G_K - L_K - A_{i,j} + K - 1$;
\item we have already placed edges between $c$ couples of different
  vertices;
\end{itemize}

Here are the constraints that $a_{i,j}$ must satisfy:
\begin{enumerate}
\item if there is not a division before $i$, then we require $a_{i,j} \geq
  a_{i-1,j}$; otherwise, just $a_{i,j} \geq 0$;
\item if there is not a division before $j$, then we require $a_{i,j}
  \geq a_{i,j-1}$;
\item we need at least $K-2-c$ (if positive) edges to connect the
  graph, because if $a_{i,j} > 0$, $c$ will increase by $1$ (this
  estimate could be very poor, but enforcing the connectedness
  condition in its entirety before completing the graph is too slow),
  hence:
  \begin{align*}
    &e^{\MAX} - a_{i,j} \geq \max(0, K-2-c)\\
    &\qquad\Rightarrow a_{i,j} \leq G - G_K - L_K - A_{i,j} +K - 1 - \max(0, K-2-c)\,\text{;}
  \end{align*}
\item $a_{i,j}$ contributes with at most $\max(0, 3-h_i) + \max(0,
  3-h_j)$ stabilizing half edges; hence, to stabilize the $p_1$ genus
  $0$ vertices, we need
  \begin{align*}
    &3p_1 - \sum_{g_{i^\prime} = 0} \min(3, n_i + 2l_i) - (\max(0, 3-h_i) + \max(0, 3-h_j)) \leq 2 (e^{\MAX} - a_{i,j})\\
    &\qquad\Rightarrow 3p_1 - \sum_{g_{i^\prime} = 0} \min(3, n_i + 2l_i) - (\max(0, 3-h_i) + \max(0, 3-h_j)) \leq \\
    &\qquad\qquad\qquad \leq 2 (G - G_K - L_K - A_{i,j} + K - 1 - a_{i,j})\\
    &\qquad\Rightarrow 2a_{i,j} \leq 2 (G - G_K - L_K - A_{i,j} + K - 1) - 3p_1 +\\
    &\qquad\qquad\qquad +\sum_{g_{i^\prime} = 0} \min(3, n_i + 2l_i) + \max(0, 3-h_i) + \max(0, 3-h_j)\,\text{.}
  \end{align*}
\item if $j = K-1$ (that is, if this is the last chance to add half
  edges to the $i$-th vertex), then we add enough edges from $i$ to
  $K-1$ in order to stabilize it; moreover, if up to now we did not
  place any non-loop edge on it, we impose $a_{i,K-1} > 0$.
\end{enumerate}

% TODO: write a new section with some data obtained by the program,
% and consideration on running time (e.g.: running time / found
% graphs)
% \section{Performance}


\begin{thebibliography}{2}

\bibitem [BMS] {busonero}
  S.~Busonero, M.~Melo, and L.~Stoppino,
  \emph{On the complexity group of stable curves},
  \arXiv{0808.1529}.%v1

\bibitem [DM] {delignemumford}
  P.~Deligne and D.~Mumford,
  \emph{The irreducibility of the space of curves of given genus},
  Inst. Hautes \'Etudes Sci. Publ. Math. \textbf{36} (1969), 75--109.

\bibitem [F] {faber}
  C.~Faber,
  \emph{Maple program for computing Hodge integrals},
  available at \href{http://math.stanford.edu/~vakil/programs/}
  {\texttt{http://math.stanford.edu/\~{}vakil/programs/}}.

\bibitem[GK] {modularoperads}
  E.~Getzler and M.~Kapranov,
  \emph{Modular Operads},
  Compositio Math. \textbf{110} (1998), no. 1, 65--126
  [\arXiv{dg-ga/9408003}].

\bibitem [M] {nauty}
  B.~D.~McKay,
  \emph{nauty},
  available at \href{http://cs.anu.edu.au/people/bdm/nauty/}
  {\texttt{http://cs.anu.edu.au/people/bdm/nauty/}}.

\bibitem [vOV1] {opstall}
  M.~A.~van~Opstall and R.~Veliche,
  \emph{Maximally symmetric stable curves},
  Michigan Math. J. \textbf{55} (2007), no. 3, 513--534
  [\arXiv{math/0603061}].

\bibitem [vOV2] {opstall2}
  M.~A.~van~Opstall and R.~Veliche,
  \emph{Maximally symmetric stable curves II},
  \arXiv{math/0608799}.%v1

\bibitem [SY] {smith}
  G.~Smith and S.~Yang,
  \emph{HodgeIntegral. Macaulay2 package for computing Hodge Integrals},
  available by request from author \href{mailto:stpyang@math.kth.se}
  {\texttt{stpyang@math.kth.se}}.

\bibitem [Y1] {stephanie1}
  S.~Yang,
  \emph{Maple program for computing integrals on $\overline{M}_{g,n}$},
  available by request from author \href{mailto:stpyang@math.kth.se}
  {\texttt{stpyang@math.kth.se}}.

\bibitem [Y2] {stephanie2}
  S.~Yang,
  \emph{Calculating intersection numbers on moduli spaces of pointed curves},
  \arXiv{0808.1974}.%v2

\end{thebibliography}
\end{document}
